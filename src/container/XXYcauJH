#pragma once
#ifndef PWX_PWXLIB_PWX_CONTAINER_TDOUBLERING_H_INCLUDED
#define PWX_PWXLIB_PWX_CONTAINER_TDOUBLERING_H_INCLUDED 1

/** @file TDoubleRing.h
  *
  * @brief Declaration of a basic template for doubly linked rings
  *
  * (c) 2007 - 2019 PrydeWorX
  * @author Sven Eden, PrydeWorX - Bardowick, Germany
  *         sven.eden@prydeworx.com
  *         https://github.com/Yamakuzure/pwxlib ; https://pwxlib.prydeworx.com
  *
  * The PrydeWorX Library is free software under MIT License
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
  * in the Software without restriction, including without limitation the rights
  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  * copies of the Software, and to permit persons to whom the Software is
  * furnished to do so, subject to the following conditions:
  *
  * The above copyright notice and this permission notice shall be included in all
  * copies or substantial portions of the Software.
  *
  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  * SOFTWARE.
  *
  * History and change log are maintained in pwxlib.h
**/


#include "TDoubleList.h"


namespace pwx {


/** @class TDoubleRing
  *
  * @brief Template to build doubly linked rings of variable types
  *
  * The doubly linked ring is a doubly linked list with a tail having a next
  * pointer to head which has a prev pointer to tail.
  *
  * The constructor takes an optional destroy(T*) function pointer that is used
  * to destroy the data when the element is deleted. If no such function was set,
  * the standard delete operator is used instead.
  *
  * It is recommended that you use the much more advanced std::list unless you
  * need to store a very large number of elements and can not live with the
  * downside of every element having to be copied into the std::list.
  *
  * @see pwx::TDoubleList for further information.
**/
template<typename data_t, typename elem_t = TDoubleElement<data_t> >
class PWX_API TDoubleRing : public TDoubleList<data_t, elem_t> {
  public:
    /* ===============================================
     * === Public types                            ===
     * ===============================================
    */

    typedef TDoubleList<data_t, elem_t> base_t; //!< Base type of the ring
    typedef TDoubleRing<data_t, elem_t> list_t; //!< Type of this ring


    /* ===============================================
     * === Public Constructors and destructors     ===
     * ===============================================
    */

    /** @brief default constructor
      *
      * The default constructor initializes an empty ring.
      *
      * @param[in] destroy_ A pointer to a function that is to be used to destroy the data
    **/
    TDoubleRing ( void ( *destroy_ ) ( data_t* data ) ) noexcept :
        base_t ( destroy_ )
    { }


    /** @brief empty constructor
      *
      * The empty constructor uses the base constructor to set the data
      * destroy method to the null pointer.
    **/
    TDoubleRing() noexcept :
        base_t ( nullptr )
    { }


    /** @brief copy constructor
      *
      * Builds a copy of all elements of @a src.
      *
      * @param[in] src reference of the ring to copy.
    **/
    TDoubleRing ( const list_t& src ) noexcept :
        base_t ( src ) {
        // TDoubleList copies the elements
        privConnectEnds(); // All we have to do here!
    }


    virtual ~TDoubleRing() noexcept;


    /* ===============================================
     * === Public methods                          ===
     * ===============================================
    */

    using base_t::clear;


    /** @brief delete the element holding the specified data
      *
      * This method deletes the element in the ring that holds @a data.
      *
      * If you intent to work with the element, use remData instead.
      *
      * @param[in] data the data the element that is to be deleted holds
      * @return the number of elements remaining in the ring after the deletion.
    **/
    virtual uint32_t delData ( data_t* data ) {
        PWX_TRY_PWX_FURTHER ( base_t::delData ( data ) )
        return privConnectEnds();
    }


    /** @brief delete the specified element
      *
      * This method deletes the element @a elem.
      *
      * If you intent to work with the element, use remElem instead.
      *
      * If @a elem is no element of this ring, the wrong ring is updated
      * and both element counts will be wrong then. So please make sure to
      * use the correct element on the correct ring!
      *
      * @param[in] elem the element that is to be deleted
      * @return the number of elements remaining in the ring after the deletion.
    **/
    virtual uint32_t delElem ( elem_t* elem ) {
        PWX_TRY_PWX_FURTHER ( base_t::delElem ( elem ) )
        return privConnectEnds();
    }


    /** @brief delete the element after the element holding the specified data
      *
      * This method deletes the element in the list after the element
      * that holds @a prev.
      *
      * If @a prev is set to nullptr, the root element (aka head) is
      * deleted.
      *
      * If you intent to work with the element, use remNext instead.
      *
      * If there is no element behind the element holding @a prev a
      * pwx::CException with the name "OutOfRange" is thrown.
      *
      * @param[in] prev the data the element that precedes the element to delete holds
      * @return the number of elements remaining in the list after the deletion.
    **/
    virtual uint32_t delNext ( data_t* prev ) {
        PWX_TRY_PWX_FURTHER ( base_t::delNext ( prev ) )
        return privConnectEnds();
    }


    /** @brief delete the element after the specified element
      *
      * This method deletes the element in the list after the element
      * @a prev.
      *
      * If @a prev is set to nullptr, the root element (aka head) is
      * deleted.
      *
      * If you intent to work with the element, use remNextElem instead.
      *
      * If @a prev is no element of this list, the wrong list is updated
      * and both element counts will be wrong then. So please make sure to
      * use the correct element on the correct list!
      *
      * If there is no element behind the element @a prev a
      * pwx::CException with the name "OutOfRange" is thrown.
      *
      * @param[in] prev the element that precedes the element to delete
      * @return the number of elements remaining in the list after the deletion.
    **/
    virtual uint32_t delNextElem ( elem_t* prev ) {
        PWX_TRY_PWX_FURTHER ( base_t::delNextElem ( prev ) )
        return privConnectEnds();
    }


    /** @brief delete the element before the element holding the specified data
      *
      * This method deletes the element in the ring before the element
      * that holds @a next.
      *
      * If @a next is set to nullptr, the last element (aka tail) is
      * deleted.
      *
      * If you intent to work with the element, use remPrev instead.
      *
      * If there is no element before the element holding @a next, a
      * pwx::CException with the name "OutOfRange" is thrown.
      *
      * @param[in] next the data the element that succeeds the element to delete holds
      * @return the number of elements remaining in the ring after the deletion.
    **/
    virtual uint32_t delPrev ( data_t* next ) {
        PWX_TRY_PWX_FURTHER ( base_t::delPrev ( next ) )
        return privConnectEnds();
    }


    /** @brief delete the element before the specified element
      *
      * This method deletes the element in the ring before the